---------------------------------------------------------------------
--
-- Copyright 2021 Ettus Research, A National Instruments Brand
-- SPDX-License-Identifier: LGPL-3.0-or-later
--
-- Module: PkgDSA_SETUP_REGMAP.vhd
--
-- Purpose:
--   The constants in this file are autogenerated by XmlParse.
--
----------------------------------------------------------------------
library ieee;
  use ieee.std_logic_1164.all;
  use ieee.numeric_std.all;

package PkgDSA_SETUP_REGMAP is

--===============================================================================
-- A numerically ordered list of registers and their HDL source files
--===============================================================================

  -- TX0_DSA_ATR          : 0x0 (dsa_control.v)
  -- TX1_DSA_ATR          : 0x400 (dsa_control.v)
  -- RX0_DSA_ATR          : 0x800 (dsa_control.v)
  -- RX1_DSA_ATR          : 0xC00 (dsa_control.v)
  -- TX0_DSA_TABLE_SELECT : 0x1000 (dsa_control.v)
  -- TX1_DSA_TABLE_SELECT : 0x1400 (dsa_control.v)
  -- RX0_DSA_TABLE_SELECT : 0x1800 (dsa_control.v)
  -- RX1_DSA_TABLE_SELECT : 0x1C00 (dsa_control.v)
  -- TX0_DSA_TABLE        : 0x2000 (dsa_control.v)
  -- TX1_DSA_TABLE        : 0x2400 (dsa_control.v)
  -- RX0_DSA_TABLE        : 0x2800 (dsa_control.v)
  -- RX1_DSA_TABLE        : 0x2C00 (dsa_control.v)

--===============================================================================
-- RegTypes
--===============================================================================

  -- DSA_TABLE_CONTROL Type (from dsa_control.v)
  constant kDSA_TABLE_CONTROLSize: integer := 32;
  constant kDSA_TABLE_CONTROLMask : std_logic_vector(31 downto 0) := X"000000ff";
  constant kTABLE_INDEXSize       : integer := 8;  --DSA_TABLE_CONTROL:TABLE_INDEX
  constant kTABLE_INDEXMsb        : integer := 7;  --DSA_TABLE_CONTROL:TABLE_INDEX
  constant kTABLE_INDEX           : integer := 0;  --DSA_TABLE_CONTROL:TABLE_INDEX

  -- RX_DSA_CONTROL Type (from dsa_control.v)
  constant kRX_DSA_CONTROLSize: integer := 32;
  constant kRX_DSA_CONTROLMask : std_logic_vector(31 downto 0) := X"0000ffff";
  constant kRX_DSA1Size       : integer := 4;  --RX_DSA_CONTROL:RX_DSA1
  constant kRX_DSA1Msb        : integer := 3;  --RX_DSA_CONTROL:RX_DSA1
  constant kRX_DSA1           : integer := 0;  --RX_DSA_CONTROL:RX_DSA1
  constant kRX_DSA2Size       : integer := 4;  --RX_DSA_CONTROL:RX_DSA2
  constant kRX_DSA2Msb        : integer := 7;  --RX_DSA_CONTROL:RX_DSA2
  constant kRX_DSA2           : integer := 4;  --RX_DSA_CONTROL:RX_DSA2
  constant kRX_DSA3_ASize       : integer :=  4;  --RX_DSA_CONTROL:RX_DSA3_A
  constant kRX_DSA3_AMsb        : integer := 11;  --RX_DSA_CONTROL:RX_DSA3_A
  constant kRX_DSA3_A           : integer :=  8;  --RX_DSA_CONTROL:RX_DSA3_A
  constant kRX_DSA3_BSize       : integer :=  4;  --RX_DSA_CONTROL:RX_DSA3_B
  constant kRX_DSA3_BMsb        : integer := 15;  --RX_DSA_CONTROL:RX_DSA3_B
  constant kRX_DSA3_B           : integer := 12;  --RX_DSA_CONTROL:RX_DSA3_B

  -- TX_DSA_CONTROL Type (from dsa_control.v)
  constant kTX_DSA_CONTROLSize: integer := 32;
  constant kTX_DSA_CONTROLMask : std_logic_vector(31 downto 0) := X"00001f1f";
  constant kTX_DSA1Size       : integer := 5;  --TX_DSA_CONTROL:TX_DSA1
  constant kTX_DSA1Msb        : integer := 4;  --TX_DSA_CONTROL:TX_DSA1
  constant kTX_DSA1           : integer := 0;  --TX_DSA_CONTROL:TX_DSA1
  constant kTX_DSA2Size       : integer :=  5;  --TX_DSA_CONTROL:TX_DSA2
  constant kTX_DSA2Msb        : integer := 12;  --TX_DSA_CONTROL:TX_DSA2
  constant kTX_DSA2           : integer :=  8;  --TX_DSA_CONTROL:TX_DSA2

--===============================================================================
-- Register Group DSA_SETUP_REGISTERS
--===============================================================================

  -- TX0_DSA_ATR Register (from dsa_control.v)
  function kTX0_DSA_ATR (i:integer) return integer; -- Register Offset function
  constant kTX0_DSA_ATRCount : integer := 256; -- Number of elements in array
  constant kTX0_DSA_ATRSize: integer := 32; -- Register bit width (not array size)
  --function kTX0_DSA_ATRRec (i:integer) return XReg2_t; -- Register Record function commented out due to programmable attributes

  -- TX1_DSA_ATR Register (from dsa_control.v)
  function kTX1_DSA_ATR (i:integer) return integer; -- Register Offset function
  constant kTX1_DSA_ATRCount : integer := 256; -- Number of elements in array
  constant kTX1_DSA_ATRSize: integer := 32; -- Register bit width (not array size)
  --function kTX1_DSA_ATRRec (i:integer) return XReg2_t; -- Register Record function commented out due to programmable attributes

  -- RX0_DSA_ATR Register (from dsa_control.v)
  function kRX0_DSA_ATR (i:integer) return integer; -- Register Offset function
  constant kRX0_DSA_ATRCount : integer := 256; -- Number of elements in array
  constant kRX0_DSA_ATRSize: integer := 32; -- Register bit width (not array size)
  --function kRX0_DSA_ATRRec (i:integer) return XReg2_t; -- Register Record function commented out due to programmable attributes

  -- RX1_DSA_ATR Register (from dsa_control.v)
  function kRX1_DSA_ATR (i:integer) return integer; -- Register Offset function
  constant kRX1_DSA_ATRCount : integer := 256; -- Number of elements in array
  constant kRX1_DSA_ATRSize: integer := 32; -- Register bit width (not array size)
  --function kRX1_DSA_ATRRec (i:integer) return XReg2_t; -- Register Record function commented out due to programmable attributes

  -- TX0_DSA_TABLE_SELECT Register (from dsa_control.v)
  function kTX0_DSA_TABLE_SELECT (i:integer) return integer; -- Register Offset function
  constant kTX0_DSA_TABLE_SELECTCount : integer := 256; -- Number of elements in array
  constant kTX0_DSA_TABLE_SELECTSize: integer := 32; -- Register bit width (not array size)
  --function kTX0_DSA_TABLE_SELECTRec (i:integer) return XReg2_t; -- Register Record function commented out due to programmable attributes

  -- TX1_DSA_TABLE_SELECT Register (from dsa_control.v)
  function kTX1_DSA_TABLE_SELECT (i:integer) return integer; -- Register Offset function
  constant kTX1_DSA_TABLE_SELECTCount : integer := 256; -- Number of elements in array
  constant kTX1_DSA_TABLE_SELECTSize: integer := 32; -- Register bit width (not array size)
  --function kTX1_DSA_TABLE_SELECTRec (i:integer) return XReg2_t; -- Register Record function commented out due to programmable attributes

  -- RX0_DSA_TABLE_SELECT Register (from dsa_control.v)
  function kRX0_DSA_TABLE_SELECT (i:integer) return integer; -- Register Offset function
  constant kRX0_DSA_TABLE_SELECTCount : integer := 256; -- Number of elements in array
  constant kRX0_DSA_TABLE_SELECTSize: integer := 32; -- Register bit width (not array size)
  --function kRX0_DSA_TABLE_SELECTRec (i:integer) return XReg2_t; -- Register Record function commented out due to programmable attributes

  -- RX1_DSA_TABLE_SELECT Register (from dsa_control.v)
  function kRX1_DSA_TABLE_SELECT (i:integer) return integer; -- Register Offset function
  constant kRX1_DSA_TABLE_SELECTCount : integer := 256; -- Number of elements in array
  constant kRX1_DSA_TABLE_SELECTSize: integer := 32; -- Register bit width (not array size)
  --function kRX1_DSA_TABLE_SELECTRec (i:integer) return XReg2_t; -- Register Record function commented out due to programmable attributes

  -- TX0_DSA_TABLE Register (from dsa_control.v)
  function kTX0_DSA_TABLE (i:integer) return integer; -- Register Offset function
  constant kTX0_DSA_TABLECount : integer := 256; -- Number of elements in array
  constant kTX0_DSA_TABLESize: integer := 32; -- Register bit width (not array size)
  --function kTX0_DSA_TABLERec (i:integer) return XReg2_t; -- Register Record function commented out due to programmable attributes

  -- TX1_DSA_TABLE Register (from dsa_control.v)
  function kTX1_DSA_TABLE (i:integer) return integer; -- Register Offset function
  constant kTX1_DSA_TABLECount : integer := 256; -- Number of elements in array
  constant kTX1_DSA_TABLESize: integer := 32; -- Register bit width (not array size)
  --function kTX1_DSA_TABLERec (i:integer) return XReg2_t; -- Register Record function commented out due to programmable attributes

  -- RX0_DSA_TABLE Register (from dsa_control.v)
  function kRX0_DSA_TABLE (i:integer) return integer; -- Register Offset function
  constant kRX0_DSA_TABLECount : integer := 256; -- Number of elements in array
  constant kRX0_DSA_TABLESize: integer := 32; -- Register bit width (not array size)
  --function kRX0_DSA_TABLERec (i:integer) return XReg2_t; -- Register Record function commented out due to programmable attributes

  -- RX1_DSA_TABLE Register (from dsa_control.v)
  function kRX1_DSA_TABLE (i:integer) return integer; -- Register Offset function
  constant kRX1_DSA_TABLECount : integer := 256; -- Number of elements in array
  constant kRX1_DSA_TABLESize: integer := 32; -- Register bit width (not array size)
  --function kRX1_DSA_TABLERec (i:integer) return XReg2_t; -- Register Record function commented out due to programmable attributes

end package;

package body PkgDSA_SETUP_REGMAP is

  -- Return the offset of an element of register array kTX0_DSA_ATR
  function kTX0_DSA_ATR (i:integer) return integer is
  begin
    --synopsys translate_off
    assert i>=0 and i<=255 report "kTX0_DSA_ATR i=" & integer'image(i) & " is out of range" severity error;
    --synopsys translate_on
    return (i * 4) + 16#0#;
  end function kTX0_DSA_ATR;

  -- function kTX0_DSA_ATRRec not implemented because TX0_DSA_ATR has programmable attributes
  ---- Return the record of an element of register array kTX0_DSA_ATR
  --function kTX0_DSA_ATRRec (i:integer) return XReg2_t is
  --  variable Rec : XReg2_t;
  --begin
  --  --synopsys translate_off
  --  assert i>=0 and i<=255 report "kTX0_DSA_ATRRec i=" & integer'image(i) & " is out of range" severity error;
  --  --synopsys translate_on
  --  Rec := kXRegDefault;
  --  Rec.version := 1;
  --  Rec.offset := (i * 4) + XAddrResize(X"0");
  --  Rec.size := 32;
  --  Rec.readable := true;
  --  Rec.writable := true;
  --  Rec.wmask := XRegResize(X"00001f1f");
  --  Rec.rmask := XRegResize(X"00001f1f");
  --  Rec.strobemask := XRegResize(X"00000000");
  --  Rec.clearablemask := XRegResize(X"00000000");
  --  Rec.initialvalue := XRegResize(X"00001F1F");
  --  -- Single-bit bitfields are not listed here because the default for msblookup* is msb=lsb.
  --  Rec.msblookupw(kTX_DSA1) := kTX_DSA1Msb;
  --  Rec.msblookupw(kTX_DSA2) := kTX_DSA2Msb;
  --  Rec.msblookupr(kTX_DSA1) := kTX_DSA1Msb;
  --  Rec.msblookupr(kTX_DSA2) := kTX_DSA2Msb;
  --  Rec.isreg := true;
  --  --synopsys translate_off
  --  Rec.name := rs("TX0_DSA_ATR");
  --  --synopsys translate_on
  --  return Rec;
  --end function kTX0_DSA_ATRRec;

  -- Return the offset of an element of register array kTX1_DSA_ATR
  function kTX1_DSA_ATR (i:integer) return integer is
  begin
    --synopsys translate_off
    assert i>=0 and i<=255 report "kTX1_DSA_ATR i=" & integer'image(i) & " is out of range" severity error;
    --synopsys translate_on
    return (i * 4) + 16#400#;
  end function kTX1_DSA_ATR;

  -- function kTX1_DSA_ATRRec not implemented because TX1_DSA_ATR has programmable attributes
  ---- Return the record of an element of register array kTX1_DSA_ATR
  --function kTX1_DSA_ATRRec (i:integer) return XReg2_t is
  --  variable Rec : XReg2_t;
  --begin
  --  --synopsys translate_off
  --  assert i>=0 and i<=255 report "kTX1_DSA_ATRRec i=" & integer'image(i) & " is out of range" severity error;
  --  --synopsys translate_on
  --  Rec := kXRegDefault;
  --  Rec.version := 1;
  --  Rec.offset := (i * 4) + XAddrResize(X"400");
  --  Rec.size := 32;
  --  Rec.readable := true;
  --  Rec.writable := true;
  --  Rec.wmask := XRegResize(X"00001f1f");
  --  Rec.rmask := XRegResize(X"00001f1f");
  --  Rec.strobemask := XRegResize(X"00000000");
  --  Rec.clearablemask := XRegResize(X"00000000");
  --  Rec.initialvalue := XRegResize(X"00001F1F");
  --  -- Single-bit bitfields are not listed here because the default for msblookup* is msb=lsb.
  --  Rec.msblookupw(kTX_DSA1) := kTX_DSA1Msb;
  --  Rec.msblookupw(kTX_DSA2) := kTX_DSA2Msb;
  --  Rec.msblookupr(kTX_DSA1) := kTX_DSA1Msb;
  --  Rec.msblookupr(kTX_DSA2) := kTX_DSA2Msb;
  --  Rec.isreg := true;
  --  --synopsys translate_off
  --  Rec.name := rs("TX1_DSA_ATR");
  --  --synopsys translate_on
  --  return Rec;
  --end function kTX1_DSA_ATRRec;

  -- Return the offset of an element of register array kRX0_DSA_ATR
  function kRX0_DSA_ATR (i:integer) return integer is
  begin
    --synopsys translate_off
    assert i>=0 and i<=255 report "kRX0_DSA_ATR i=" & integer'image(i) & " is out of range" severity error;
    --synopsys translate_on
    return (i * 4) + 16#800#;
  end function kRX0_DSA_ATR;

  -- function kRX0_DSA_ATRRec not implemented because RX0_DSA_ATR has programmable attributes
  ---- Return the record of an element of register array kRX0_DSA_ATR
  --function kRX0_DSA_ATRRec (i:integer) return XReg2_t is
  --  variable Rec : XReg2_t;
  --begin
  --  --synopsys translate_off
  --  assert i>=0 and i<=255 report "kRX0_DSA_ATRRec i=" & integer'image(i) & " is out of range" severity error;
  --  --synopsys translate_on
  --  Rec := kXRegDefault;
  --  Rec.version := 1;
  --  Rec.offset := (i * 4) + XAddrResize(X"800");
  --  Rec.size := 32;
  --  Rec.readable := true;
  --  Rec.writable := true;
  --  Rec.wmask := XRegResize(X"0000ffff");
  --  Rec.rmask := XRegResize(X"0000ffff");
  --  Rec.strobemask := XRegResize(X"00000000");
  --  Rec.clearablemask := XRegResize(X"00000000");
  --  Rec.initialvalue := XRegResize(X"0000FFFF");
  --  -- Single-bit bitfields are not listed here because the default for msblookup* is msb=lsb.
  --  Rec.msblookupw(kRX_DSA1) := kRX_DSA1Msb;
  --  Rec.msblookupw(kRX_DSA2) := kRX_DSA2Msb;
  --  Rec.msblookupw(kRX_DSA3_A) := kRX_DSA3_AMsb;
  --  Rec.msblookupw(kRX_DSA3_B) := kRX_DSA3_BMsb;
  --  Rec.msblookupr(kRX_DSA1) := kRX_DSA1Msb;
  --  Rec.msblookupr(kRX_DSA2) := kRX_DSA2Msb;
  --  Rec.msblookupr(kRX_DSA3_A) := kRX_DSA3_AMsb;
  --  Rec.msblookupr(kRX_DSA3_B) := kRX_DSA3_BMsb;
  --  Rec.isreg := true;
  --  --synopsys translate_off
  --  Rec.name := rs("RX0_DSA_ATR");
  --  --synopsys translate_on
  --  return Rec;
  --end function kRX0_DSA_ATRRec;

  -- Return the offset of an element of register array kRX1_DSA_ATR
  function kRX1_DSA_ATR (i:integer) return integer is
  begin
    --synopsys translate_off
    assert i>=0 and i<=255 report "kRX1_DSA_ATR i=" & integer'image(i) & " is out of range" severity error;
    --synopsys translate_on
    return (i * 4) + 16#C00#;
  end function kRX1_DSA_ATR;

  -- function kRX1_DSA_ATRRec not implemented because RX1_DSA_ATR has programmable attributes
  ---- Return the record of an element of register array kRX1_DSA_ATR
  --function kRX1_DSA_ATRRec (i:integer) return XReg2_t is
  --  variable Rec : XReg2_t;
  --begin
  --  --synopsys translate_off
  --  assert i>=0 and i<=255 report "kRX1_DSA_ATRRec i=" & integer'image(i) & " is out of range" severity error;
  --  --synopsys translate_on
  --  Rec := kXRegDefault;
  --  Rec.version := 1;
  --  Rec.offset := (i * 4) + XAddrResize(X"C00");
  --  Rec.size := 32;
  --  Rec.readable := true;
  --  Rec.writable := true;
  --  Rec.wmask := XRegResize(X"0000ffff");
  --  Rec.rmask := XRegResize(X"0000ffff");
  --  Rec.strobemask := XRegResize(X"00000000");
  --  Rec.clearablemask := XRegResize(X"00000000");
  --  Rec.initialvalue := XRegResize(X"0000FFFF");
  --  -- Single-bit bitfields are not listed here because the default for msblookup* is msb=lsb.
  --  Rec.msblookupw(kRX_DSA1) := kRX_DSA1Msb;
  --  Rec.msblookupw(kRX_DSA2) := kRX_DSA2Msb;
  --  Rec.msblookupw(kRX_DSA3_A) := kRX_DSA3_AMsb;
  --  Rec.msblookupw(kRX_DSA3_B) := kRX_DSA3_BMsb;
  --  Rec.msblookupr(kRX_DSA1) := kRX_DSA1Msb;
  --  Rec.msblookupr(kRX_DSA2) := kRX_DSA2Msb;
  --  Rec.msblookupr(kRX_DSA3_A) := kRX_DSA3_AMsb;
  --  Rec.msblookupr(kRX_DSA3_B) := kRX_DSA3_BMsb;
  --  Rec.isreg := true;
  --  --synopsys translate_off
  --  Rec.name := rs("RX1_DSA_ATR");
  --  --synopsys translate_on
  --  return Rec;
  --end function kRX1_DSA_ATRRec;

  -- Return the offset of an element of register array kTX0_DSA_TABLE_SELECT
  function kTX0_DSA_TABLE_SELECT (i:integer) return integer is
  begin
    --synopsys translate_off
    assert i>=0 and i<=255 report "kTX0_DSA_TABLE_SELECT i=" & integer'image(i) & " is out of range" severity error;
    --synopsys translate_on
    return (i * 4) + 16#1000#;
  end function kTX0_DSA_TABLE_SELECT;

  -- function kTX0_DSA_TABLE_SELECTRec not implemented because TX0_DSA_TABLE_SELECT has programmable attributes
  ---- Return the record of an element of register array kTX0_DSA_TABLE_SELECT
  --function kTX0_DSA_TABLE_SELECTRec (i:integer) return XReg2_t is
  --  variable Rec : XReg2_t;
  --begin
  --  --synopsys translate_off
  --  assert i>=0 and i<=255 report "kTX0_DSA_TABLE_SELECTRec i=" & integer'image(i) & " is out of range" severity error;
  --  --synopsys translate_on
  --  Rec := kXRegDefault;
  --  Rec.version := 1;
  --  Rec.offset := (i * 4) + XAddrResize(X"1000");
  --  Rec.size := 32;
  --  Rec.readable := false;
  --  Rec.writable := true;
  --  Rec.wmask := XRegResize(X"000000ff");
  --  Rec.rmask := XRegResize(X"00000000");
  --  Rec.strobemask := XRegResize(X"00000000");
  --  Rec.clearablemask := XRegResize(X"00000000");
  --  -- no initial values specified
  --  -- Single-bit bitfields are not listed here because the default for msblookup* is msb=lsb.
  --  Rec.msblookupw(kTABLE_INDEX) := kTABLE_INDEXMsb;
  --  Rec.isreg := true;
  --  --synopsys translate_off
  --  Rec.name := rs("TX0_DSA_TABLE_SELECT");
  --  --synopsys translate_on
  --  return Rec;
  --end function kTX0_DSA_TABLE_SELECTRec;

  -- Return the offset of an element of register array kTX1_DSA_TABLE_SELECT
  function kTX1_DSA_TABLE_SELECT (i:integer) return integer is
  begin
    --synopsys translate_off
    assert i>=0 and i<=255 report "kTX1_DSA_TABLE_SELECT i=" & integer'image(i) & " is out of range" severity error;
    --synopsys translate_on
    return (i * 4) + 16#1400#;
  end function kTX1_DSA_TABLE_SELECT;

  -- function kTX1_DSA_TABLE_SELECTRec not implemented because TX1_DSA_TABLE_SELECT has programmable attributes
  ---- Return the record of an element of register array kTX1_DSA_TABLE_SELECT
  --function kTX1_DSA_TABLE_SELECTRec (i:integer) return XReg2_t is
  --  variable Rec : XReg2_t;
  --begin
  --  --synopsys translate_off
  --  assert i>=0 and i<=255 report "kTX1_DSA_TABLE_SELECTRec i=" & integer'image(i) & " is out of range" severity error;
  --  --synopsys translate_on
  --  Rec := kXRegDefault;
  --  Rec.version := 1;
  --  Rec.offset := (i * 4) + XAddrResize(X"1400");
  --  Rec.size := 32;
  --  Rec.readable := false;
  --  Rec.writable := true;
  --  Rec.wmask := XRegResize(X"000000ff");
  --  Rec.rmask := XRegResize(X"00000000");
  --  Rec.strobemask := XRegResize(X"00000000");
  --  Rec.clearablemask := XRegResize(X"00000000");
  --  -- no initial values specified
  --  -- Single-bit bitfields are not listed here because the default for msblookup* is msb=lsb.
  --  Rec.msblookupw(kTABLE_INDEX) := kTABLE_INDEXMsb;
  --  Rec.isreg := true;
  --  --synopsys translate_off
  --  Rec.name := rs("TX1_DSA_TABLE_SELECT");
  --  --synopsys translate_on
  --  return Rec;
  --end function kTX1_DSA_TABLE_SELECTRec;

  -- Return the offset of an element of register array kRX0_DSA_TABLE_SELECT
  function kRX0_DSA_TABLE_SELECT (i:integer) return integer is
  begin
    --synopsys translate_off
    assert i>=0 and i<=255 report "kRX0_DSA_TABLE_SELECT i=" & integer'image(i) & " is out of range" severity error;
    --synopsys translate_on
    return (i * 4) + 16#1800#;
  end function kRX0_DSA_TABLE_SELECT;

  -- function kRX0_DSA_TABLE_SELECTRec not implemented because RX0_DSA_TABLE_SELECT has programmable attributes
  ---- Return the record of an element of register array kRX0_DSA_TABLE_SELECT
  --function kRX0_DSA_TABLE_SELECTRec (i:integer) return XReg2_t is
  --  variable Rec : XReg2_t;
  --begin
  --  --synopsys translate_off
  --  assert i>=0 and i<=255 report "kRX0_DSA_TABLE_SELECTRec i=" & integer'image(i) & " is out of range" severity error;
  --  --synopsys translate_on
  --  Rec := kXRegDefault;
  --  Rec.version := 1;
  --  Rec.offset := (i * 4) + XAddrResize(X"1800");
  --  Rec.size := 32;
  --  Rec.readable := false;
  --  Rec.writable := true;
  --  Rec.wmask := XRegResize(X"000000ff");
  --  Rec.rmask := XRegResize(X"00000000");
  --  Rec.strobemask := XRegResize(X"00000000");
  --  Rec.clearablemask := XRegResize(X"00000000");
  --  -- no initial values specified
  --  -- Single-bit bitfields are not listed here because the default for msblookup* is msb=lsb.
  --  Rec.msblookupw(kTABLE_INDEX) := kTABLE_INDEXMsb;
  --  Rec.isreg := true;
  --  --synopsys translate_off
  --  Rec.name := rs("RX0_DSA_TABLE_SELECT");
  --  --synopsys translate_on
  --  return Rec;
  --end function kRX0_DSA_TABLE_SELECTRec;

  -- Return the offset of an element of register array kRX1_DSA_TABLE_SELECT
  function kRX1_DSA_TABLE_SELECT (i:integer) return integer is
  begin
    --synopsys translate_off
    assert i>=0 and i<=255 report "kRX1_DSA_TABLE_SELECT i=" & integer'image(i) & " is out of range" severity error;
    --synopsys translate_on
    return (i * 4) + 16#1C00#;
  end function kRX1_DSA_TABLE_SELECT;

  -- function kRX1_DSA_TABLE_SELECTRec not implemented because RX1_DSA_TABLE_SELECT has programmable attributes
  ---- Return the record of an element of register array kRX1_DSA_TABLE_SELECT
  --function kRX1_DSA_TABLE_SELECTRec (i:integer) return XReg2_t is
  --  variable Rec : XReg2_t;
  --begin
  --  --synopsys translate_off
  --  assert i>=0 and i<=255 report "kRX1_DSA_TABLE_SELECTRec i=" & integer'image(i) & " is out of range" severity error;
  --  --synopsys translate_on
  --  Rec := kXRegDefault;
  --  Rec.version := 1;
  --  Rec.offset := (i * 4) + XAddrResize(X"1C00");
  --  Rec.size := 32;
  --  Rec.readable := false;
  --  Rec.writable := true;
  --  Rec.wmask := XRegResize(X"000000ff");
  --  Rec.rmask := XRegResize(X"00000000");
  --  Rec.strobemask := XRegResize(X"00000000");
  --  Rec.clearablemask := XRegResize(X"00000000");
  --  -- no initial values specified
  --  -- Single-bit bitfields are not listed here because the default for msblookup* is msb=lsb.
  --  Rec.msblookupw(kTABLE_INDEX) := kTABLE_INDEXMsb;
  --  Rec.isreg := true;
  --  --synopsys translate_off
  --  Rec.name := rs("RX1_DSA_TABLE_SELECT");
  --  --synopsys translate_on
  --  return Rec;
  --end function kRX1_DSA_TABLE_SELECTRec;

  -- Return the offset of an element of register array kTX0_DSA_TABLE
  function kTX0_DSA_TABLE (i:integer) return integer is
  begin
    --synopsys translate_off
    assert i>=0 and i<=255 report "kTX0_DSA_TABLE i=" & integer'image(i) & " is out of range" severity error;
    --synopsys translate_on
    return (i * 4) + 16#2000#;
  end function kTX0_DSA_TABLE;

  -- function kTX0_DSA_TABLERec not implemented because TX0_DSA_TABLE has programmable attributes
  ---- Return the record of an element of register array kTX0_DSA_TABLE
  --function kTX0_DSA_TABLERec (i:integer) return XReg2_t is
  --  variable Rec : XReg2_t;
  --begin
  --  --synopsys translate_off
  --  assert i>=0 and i<=255 report "kTX0_DSA_TABLERec i=" & integer'image(i) & " is out of range" severity error;
  --  --synopsys translate_on
  --  Rec := kXRegDefault;
  --  Rec.version := 1;
  --  Rec.offset := (i * 4) + XAddrResize(X"2000");
  --  Rec.size := 32;
  --  Rec.readable := true;
  --  Rec.writable := true;
  --  Rec.wmask := XRegResize(X"00001f1f");
  --  Rec.rmask := XRegResize(X"00001f1f");
  --  Rec.strobemask := XRegResize(X"00000000");
  --  Rec.clearablemask := XRegResize(X"00000000");
  --  Rec.initialvalue := XRegResize(X"00001F1F");
  --  -- Single-bit bitfields are not listed here because the default for msblookup* is msb=lsb.
  --  Rec.msblookupw(kTX_DSA1) := kTX_DSA1Msb;
  --  Rec.msblookupw(kTX_DSA2) := kTX_DSA2Msb;
  --  Rec.msblookupr(kTX_DSA1) := kTX_DSA1Msb;
  --  Rec.msblookupr(kTX_DSA2) := kTX_DSA2Msb;
  --  Rec.isreg := true;
  --  --synopsys translate_off
  --  Rec.name := rs("TX0_DSA_TABLE");
  --  --synopsys translate_on
  --  return Rec;
  --end function kTX0_DSA_TABLERec;

  -- Return the offset of an element of register array kTX1_DSA_TABLE
  function kTX1_DSA_TABLE (i:integer) return integer is
  begin
    --synopsys translate_off
    assert i>=0 and i<=255 report "kTX1_DSA_TABLE i=" & integer'image(i) & " is out of range" severity error;
    --synopsys translate_on
    return (i * 4) + 16#2400#;
  end function kTX1_DSA_TABLE;

  -- function kTX1_DSA_TABLERec not implemented because TX1_DSA_TABLE has programmable attributes
  ---- Return the record of an element of register array kTX1_DSA_TABLE
  --function kTX1_DSA_TABLERec (i:integer) return XReg2_t is
  --  variable Rec : XReg2_t;
  --begin
  --  --synopsys translate_off
  --  assert i>=0 and i<=255 report "kTX1_DSA_TABLERec i=" & integer'image(i) & " is out of range" severity error;
  --  --synopsys translate_on
  --  Rec := kXRegDefault;
  --  Rec.version := 1;
  --  Rec.offset := (i * 4) + XAddrResize(X"2400");
  --  Rec.size := 32;
  --  Rec.readable := true;
  --  Rec.writable := true;
  --  Rec.wmask := XRegResize(X"00001f1f");
  --  Rec.rmask := XRegResize(X"00001f1f");
  --  Rec.strobemask := XRegResize(X"00000000");
  --  Rec.clearablemask := XRegResize(X"00000000");
  --  Rec.initialvalue := XRegResize(X"00001F1F");
  --  -- Single-bit bitfields are not listed here because the default for msblookup* is msb=lsb.
  --  Rec.msblookupw(kTX_DSA1) := kTX_DSA1Msb;
  --  Rec.msblookupw(kTX_DSA2) := kTX_DSA2Msb;
  --  Rec.msblookupr(kTX_DSA1) := kTX_DSA1Msb;
  --  Rec.msblookupr(kTX_DSA2) := kTX_DSA2Msb;
  --  Rec.isreg := true;
  --  --synopsys translate_off
  --  Rec.name := rs("TX1_DSA_TABLE");
  --  --synopsys translate_on
  --  return Rec;
  --end function kTX1_DSA_TABLERec;

  -- Return the offset of an element of register array kRX0_DSA_TABLE
  function kRX0_DSA_TABLE (i:integer) return integer is
  begin
    --synopsys translate_off
    assert i>=0 and i<=255 report "kRX0_DSA_TABLE i=" & integer'image(i) & " is out of range" severity error;
    --synopsys translate_on
    return (i * 4) + 16#2800#;
  end function kRX0_DSA_TABLE;

  -- function kRX0_DSA_TABLERec not implemented because RX0_DSA_TABLE has programmable attributes
  ---- Return the record of an element of register array kRX0_DSA_TABLE
  --function kRX0_DSA_TABLERec (i:integer) return XReg2_t is
  --  variable Rec : XReg2_t;
  --begin
  --  --synopsys translate_off
  --  assert i>=0 and i<=255 report "kRX0_DSA_TABLERec i=" & integer'image(i) & " is out of range" severity error;
  --  --synopsys translate_on
  --  Rec := kXRegDefault;
  --  Rec.version := 1;
  --  Rec.offset := (i * 4) + XAddrResize(X"2800");
  --  Rec.size := 32;
  --  Rec.readable := true;
  --  Rec.writable := true;
  --  Rec.wmask := XRegResize(X"0000ffff");
  --  Rec.rmask := XRegResize(X"0000ffff");
  --  Rec.strobemask := XRegResize(X"00000000");
  --  Rec.clearablemask := XRegResize(X"00000000");
  --  Rec.initialvalue := XRegResize(X"0000FFFF");
  --  -- Single-bit bitfields are not listed here because the default for msblookup* is msb=lsb.
  --  Rec.msblookupw(kRX_DSA1) := kRX_DSA1Msb;
  --  Rec.msblookupw(kRX_DSA2) := kRX_DSA2Msb;
  --  Rec.msblookupw(kRX_DSA3_A) := kRX_DSA3_AMsb;
  --  Rec.msblookupw(kRX_DSA3_B) := kRX_DSA3_BMsb;
  --  Rec.msblookupr(kRX_DSA1) := kRX_DSA1Msb;
  --  Rec.msblookupr(kRX_DSA2) := kRX_DSA2Msb;
  --  Rec.msblookupr(kRX_DSA3_A) := kRX_DSA3_AMsb;
  --  Rec.msblookupr(kRX_DSA3_B) := kRX_DSA3_BMsb;
  --  Rec.isreg := true;
  --  --synopsys translate_off
  --  Rec.name := rs("RX0_DSA_TABLE");
  --  --synopsys translate_on
  --  return Rec;
  --end function kRX0_DSA_TABLERec;

  -- Return the offset of an element of register array kRX1_DSA_TABLE
  function kRX1_DSA_TABLE (i:integer) return integer is
  begin
    --synopsys translate_off
    assert i>=0 and i<=255 report "kRX1_DSA_TABLE i=" & integer'image(i) & " is out of range" severity error;
    --synopsys translate_on
    return (i * 4) + 16#2C00#;
  end function kRX1_DSA_TABLE;

  -- function kRX1_DSA_TABLERec not implemented because RX1_DSA_TABLE has programmable attributes
  ---- Return the record of an element of register array kRX1_DSA_TABLE
  --function kRX1_DSA_TABLERec (i:integer) return XReg2_t is
  --  variable Rec : XReg2_t;
  --begin
  --  --synopsys translate_off
  --  assert i>=0 and i<=255 report "kRX1_DSA_TABLERec i=" & integer'image(i) & " is out of range" severity error;
  --  --synopsys translate_on
  --  Rec := kXRegDefault;
  --  Rec.version := 1;
  --  Rec.offset := (i * 4) + XAddrResize(X"2C00");
  --  Rec.size := 32;
  --  Rec.readable := true;
  --  Rec.writable := true;
  --  Rec.wmask := XRegResize(X"0000ffff");
  --  Rec.rmask := XRegResize(X"0000ffff");
  --  Rec.strobemask := XRegResize(X"00000000");
  --  Rec.clearablemask := XRegResize(X"00000000");
  --  Rec.initialvalue := XRegResize(X"0000FFFF");
  --  -- Single-bit bitfields are not listed here because the default for msblookup* is msb=lsb.
  --  Rec.msblookupw(kRX_DSA1) := kRX_DSA1Msb;
  --  Rec.msblookupw(kRX_DSA2) := kRX_DSA2Msb;
  --  Rec.msblookupw(kRX_DSA3_A) := kRX_DSA3_AMsb;
  --  Rec.msblookupw(kRX_DSA3_B) := kRX_DSA3_BMsb;
  --  Rec.msblookupr(kRX_DSA1) := kRX_DSA1Msb;
  --  Rec.msblookupr(kRX_DSA2) := kRX_DSA2Msb;
  --  Rec.msblookupr(kRX_DSA3_A) := kRX_DSA3_AMsb;
  --  Rec.msblookupr(kRX_DSA3_B) := kRX_DSA3_BMsb;
  --  Rec.isreg := true;
  --  --synopsys translate_off
  --  Rec.name := rs("RX1_DSA_TABLE");
  --  --synopsys translate_on
  --  return Rec;
  --end function kRX1_DSA_TABLERec;

end package body;
